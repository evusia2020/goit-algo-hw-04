# Висновки щодо ефективності алгоритмів сортування

## Огляд завдання

Метою цього завдання було порівняти ефективність трьох алгоритмів сортування:
1. **Алгоритм сортування злиттям (Merge Sort)**
2. **Алгоритм сортування вставками (Insertion Sort)**
3. **Timsort** — гібридний алгоритм сортування, використаний в Python

Для порівняння було використано модуль `timeit` для вимірювання часу виконання кожного алгоритму на різних наборах даних:
- Випадкові масиви
- Відсортовані масиви
- Зворотно відсортовані масиви
- Великі масиви для перевірки ефективності на великих наборах даних.

### Висновки

#### 1. **Алгоритм сортування злиттям (Merge Sort)**

**Складність:** O(n log n)

- **Переваги:**
  - Показує стабільно хороший результат для великих масивів.
  - Має гарну теоретичну складність O(n log n), що робить його дуже ефективним для великих обсягів даних.
- **Недоліки:**
  - Для малих масивів може бути менш ефективним через накладні витрати на рекурсивне розбиття масивів.
  - Потрібна додаткова пам'ять, оскільки масиви потрібно зберігати в окремих підмасивах.
  
**Результати тестування:** Алгоритм сортування злиттям показав хороші результати на великих масивах, але на маленьких або частково відсортованих даних він був менш ефективним у порівнянні з іншими алгоритмами.

#### 2. **Алгоритм сортування вставками (Insertion Sort)**

**Складність:** O(n^2)

- **Переваги:**
  - Дуже простий і швидкий для невеликих або частково відсортованих масивів.
  - Не потребує додаткової пам'яті, оскільки працює безпосередньо на даних.
- **Недоліки:**
  - Для великих масивів показує квадратичну складність (O(n^2)), що робить його дуже повільним при великих наборах даних.
  - Не підходить для сортування великих масивів через значні витрати часу.

**Результати тестування:** Алгоритм сортування вставками виявився найшвидшим для невеликих або майже відсортованих даних, але на великих випадкових масивах його час виконання різко збільшувався, і він виявився значно повільнішим за сортування злиттям та Timsort.

#### 3. **Алгоритм Timsort**

**Складність:** O(n log n) у найгіршому випадку

- **Переваги:**
  - Timsort є поєднанням сортування злиттям та сортування вставками, що дозволяє йому ефективно працювати як з великими, так і з малими масивами.
  - Показує виняткові результати на частково відсортованих масивах, де алгоритм може використовувати переваги вже відсортованих частин.
  - Це стандартний алгоритм сортування в Python, що підтверджує його високу ефективність.
- **Недоліки:**
  - Порівняно складний у реалізації, особливо при спробі створити власний варіант.
  - Потрібна додаткова пам'ять для збереження проміжних результатів під час злиття.

**Результати тестування:** Timsort продемонстрував найкращі результати серед усіх алгоритмів, особливо на великих масивах. Він працював дуже швидко і на випадкових, і на частково відсортованих даних. Його час виконання був стабільним і дуже швидким.

### 4. **Висновок**

- **Timsort є найбільш ефективним алгоритмом для сортування в Python** завдяки своїй адаптивності до різних типів даних. Алгоритм поєднує переваги сортування злиттям для великих масивів та сортування вставками для малих підмасивів, що робить його надзвичайно швидким і адаптивним до реальних умов.
- **Сортування злиттям** є хорошим вибором для сортування великих масивів, але вимагає додаткової пам'яті, що може бути проблемою при обмежених ресурсах.
- **Сортування вставками** є швидким для малих або частково відсортованих масивів, але не підходить для великих наборів даних через квадратичну складність.

### 5. **Рекомендації**

- **Для більшості задач у Python** найкраще використовувати вбудовані функції `sorted` або метод `.sort()`, оскільки Timsort є найоптимальнішим для різних випадків.
- **Для великих масивів** краще використовувати алгоритм сортування злиттям або Timsort.
- **Для невеликих або частково відсортованих даних** можна застосовувати сортування вставками, оскільки цей алгоритм є дуже швидким для таких випадків.
